#!/usr/bin/env perl
use strict;
use warnings;
use Modern::Perl '2011';
use autodie;
use Smart::Comments;
use warnings FATAL => 'uninitialized';
use Date::Manip;
use POSIX qw(strftime);
use Date::Calc qw(Day_of_Year);
use Tie::IxHash;

# Ensure minimum number of arguments
unless (@ARGV >= 3) {
    die << "EOT";
Usage: $0 <infile.fasta> <n chain> <n report>
This tool reformats FASTA IDs for treetime and BEAST analysis.
Example: $0 test.fasta 10000 1000000
EOT
}

# Input parameters
my $seq_file = shift;
my $chain    = shift;
my $report   = shift;
my $report2  = $report * 10;

# Extract base name from file
my ($outname) = $seq_file =~ m/([^\/]+)\.\w+$/;

# Read sequences from FASTA
tie my %seq_for, 'Tie::IxHash';
%seq_for = read_fasta($seq_file);

# Get sequence details
my @keys = keys %seq_for;
die "Error: Insufficient sequences. Minimum of 3 required.\n" if scalar @keys < 3;

my $num = scalar keys %seq_for;
my $len = length($seq_for{ $keys[0] }{"sequence"});

# Open output XML file
my $outfile1 = "${outname}_formatted.xml";
open my $out, '>', $outfile1;

# XML Header
print {$out} <<'XML';
<?xml version="1.0" standalone="yes"?>
<!-- Generated by BEAUTi v1.10.4 -->
<beast version="1.10.4">
    <!-- Taxa List -->
XML

# Taxa block
print {$out} qq(    <taxa id="taxa">\n);
for my $ids (keys %seq_for) {
    my $date       = $seq_for{$ids}{"date"};
    my $uncertainty = $seq_for{$ids}{"uncertainty"};

    if ($uncertainty > 0) {
        print {$out} qq(        <taxon id="$ids">\n);
        print {$out} qq(            <date value="$date" direction="forwards" units="years" uncertainty="$uncertainty"/>\n);
        print {$out} qq(        </taxon>\n);
    } else {
        print {$out} qq(        <taxon id="$ids">\n);
        print {$out} qq(            <date value="$date" direction="forwards" units="years"/>\n);
        print {$out} qq(        </taxon>\n);
    }
}
print {$out} qq(    </taxa>\n\n);

# Alignment block
print {$out} qq(    <alignment id="alignment" dataType="nucleotide">\n);
for my $ids (keys %seq_for) {
    my $sequence = $seq_for{$ids}{"sequence"};
    print {$out} qq(        <sequence>\n);
    print {$out} qq(            <taxon idref="$ids"/>\n);
    print {$out} qq(            $sequence\n);
    print {$out} qq(        </sequence>\n);
}
print {$out} qq(    </alignment>\n\n);

# Additional XML components (e.g., patterns, priors, etc.)
print {$out} qq(    <!-- Patterns and Priors -->\n);

# Operators for uncertain dates
for my $ids (keys %seq_for) {
    if ($seq_for{$ids}{"uncertainty"} > 0) {
        print {$out} qq(    <uniformOperator weight="1">\n);
        print {$out} qq(        <parameter idref="age($ids)"/>\n);
        print {$out} qq(    </uniformOperator>\n);
    }
}

# MCMC Block
print {$out} qq(    <mcmc id="mcmc" chainLength="$chain" autoOptimize="true">\n);
print {$out} qq(        <log id="screenLog" logEvery="$report">\n);
print {$out} qq(            <column label="Joint" dp="4" width="12">\n);
print {$out} qq(                <joint idref="joint"/>\n);
print {$out} qq(            </column>\n);
print {$out} qq(        </log>\n);
print {$out} qq(    </mcmc>\n\n);

print {$out} qq(</beast>\n);
close $out;

# Subroutine to read FASTA
sub read_fasta {
    my ($infile) = @_;
    open my $in, '<', $infile;

    my %seq_for;
    my ($seq_id, $seq, $dates, $date_convert);
    my $uncertainty = 0;

    tie %seq_for, 'Tie::IxHash';

    while (my $line = <$in>) {
        chomp $line;

        if ($line =~ m/(.*\|([\d\-]+))/xms) {
            if ($seq) {
                $seq_for{$seq_id} = {
                    sequence   => $seq,
                    date       => $date_convert,
                    uncertainty => $uncertainty
                };
            }
            $seq      = q{};
            $seq_id   = $1;
            $dates    = $2;
            $uncertainty = 0;

            my ($year) = $dates =~ m/^(\d{4})/xms;
            if (defined $year) {
                if ($dates =~ m/^\d{4}\-\d{2}\-\d{2}$/xms) {
                    $uncertainty = 0;
                } elsif ($dates =~ m/^\d{4}\-\d{2}$/xms) {
                    $uncertainty = 0.0833;  # Approximation for mid-month
                } elsif ($dates =~ m/^\d{4}$/xms) {
                    $uncertainty = 1.0;  # Whole year uncertainty
                }
                $date_convert = $year;
            } else {
                $date_convert = "invalid";
            }
        } else {
            $seq .= $line;
        }
    }

    # Add the final sequence
    $seq_for{$seq_id} = {
        sequence   => $seq,
        date       => $date_convert,
        uncertainty => $uncertainty
    } if $seq;

    close $in;
    return %seq_for;
}
